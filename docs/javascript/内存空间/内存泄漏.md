# 内存泄漏

## 什么是内存泄漏?

不再用到的内存, 没有及时释放, 就叫做内存泄漏(`memory leak`)

## 常见的内存泄漏类型及避免措施

### 意外的全局变量

```js
function test() {
	a = "112138"
	this.b = 12138
}

test()
```

函数内部声明, 未使用 `var` 关键字, 意外创建全局变量 `a`;

函数调用, 内部 `this` 指向全局对象 `window`;

::: tip
JavaScript 文件头部加上 `"use strict;"`, 启用严格模式解析 JavaScript, 避免意外的全局变量.
:::

### 被遗忘的计时器或回调函数

```js
var bigData = getBigData()

setInterval(() => {
	var root = document.getElementById("root")
	if (root) {
		root.innerHTML = JSON.stringify(bigData)
	}
}, 1000)
```

计时器未停止, 回调函数未被回收, 其引用的 `bigData` 同样无法被回收.

::: tip
计时器用完及时 clearInterval/clearTimeout
:::

### 脱离 DOM 的引用/未清除 DOM 引用

```js
var text = document.getElementById("text")
document.body.removeChild(text)
```

::: tip

#### `Element#text` 不能够被回收, 变量 `text` 对其存在引用.

解决方案: `text = null`

:::

```js
var elements = {
	button: document.getElementById("button"),
	text: document.getElementById("text")
}

elements.button.onclick = function() {
	elements.text.innerHTML = "9527"
}

function removeButton() {
	document.body.removeChild(document.getElementById("button"))
}

removeButton()
```

::: tip

#### `Element#button` 不能够被回收, 绑定事件未被移除, 对其存在引用.

解决方案: `text = null`

:::

### 闭包

匿名函数可以访问父级作用域的变量。
